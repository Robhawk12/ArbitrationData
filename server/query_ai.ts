import { OpenAI } from "openai";
import { db } from "./db";
import { sql } from "drizzle-orm";
import { arbitrationCases } from "../shared/schema";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Types for the query response
export type QueryResult = {
  answer_type: "count" | "average" | "list" | "error" | "fallback";
  value?: number;
  items?: string[];
  summary: string;
  error?: string;
  sql_query?: string;
  fallback_used?: boolean;
};

// Function to safely execute a SQL query generated by AI
export async function executeSqlQuery(sqlQuery: string): Promise<QueryResult> {
  try {
    // Basic SQL injection prevention
    // Check for multiple statements or dangerous operations
    if (
      sqlQuery.includes(";") && !sqlQuery.endsWith(";") ||
      /\b(DELETE|DROP|TRUNCATE|ALTER|UPDATE)\b/i.test(sqlQuery)
    ) {
      return {
        answer_type: "error",
        summary: "The generated query contains potentially unsafe operations.",
        error: "Unsafe SQL query detected",
      };
    }

    // Execute the query
    const result = await db.execute(sql.raw(sqlQuery));
    
    // Convert result to array for easier processing
    // Using any[] type here because PostgreSQL results can vary in structure
    const queryResult: any[] = Array.isArray(result) ? result : [result];
    
    // Determine the type of query result
    if (!queryResult || queryResult.length === 0) {
      return {
        answer_type: "count",
        value: 0,
        summary: "No results found for your query.",
        sql_query: sqlQuery,
      };
    }

    const firstRow = queryResult[0];
    
    // Skip if there's no data
    if (!firstRow) {
      return {
        answer_type: "count",
        value: 0,
        summary: "No results found for your query.",
        sql_query: sqlQuery,
      };
    }
    
    // Handle count queries
    if (
      'count' in firstRow || 
      'COUNT' in firstRow || 
      Object.values(firstRow).some(val => 
        typeof val === 'number' || 
        (typeof val === 'string' && !isNaN(Number(val)))
      )
    ) {
      const countKey = 'count' in firstRow ? 'count' : 
                       'COUNT' in firstRow ? 'COUNT' : 
                       Object.keys(firstRow)[0];
      const count = Number(firstRow[countKey]);
      return {
        answer_type: "count",
        value: count,
        summary: `Found ${count} results.`,
        sql_query: sqlQuery,
      };
    }
    
    // Handle average queries
    if (
      'avg' in firstRow || 
      'average' in firstRow || 
      'AVG' in firstRow || 
      Object.keys(firstRow).some(k => k.toLowerCase().includes('avg'))
    ) {
      const avgKey = Object.keys(firstRow).find(k => 
        k.toLowerCase().includes('avg') || 
        k.toLowerCase().includes('average')
      ) || Object.keys(firstRow)[0];
      
      const avg = Number(firstRow[avgKey]);
      
      // Format the average as currency if it's an award amount
      const formattedAvg = avgKey.toLowerCase().includes('award') ? 
        new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(avg) : 
        avg.toString();
      
      return {
        answer_type: "average",
        value: avg,
        summary: `The average is ${formattedAvg}.`,
        sql_query: sqlQuery,
      };
    }
    
    // Handle list queries (assuming everything else is a list)
    const items: string[] = queryResult.map((row: any) => {
      if (!row) return "Unknown";
      
      // If the row has specific important fields, format them nicely
      if (row.caseId || row.case_id) {
        const caseId = row.caseId || row.case_id;
        const arbitrator = row.arbitratorName || row.arbitrator_name || '';
        const respondent = row.respondentName || row.respondent_name || '';
        return `Case ${caseId}${arbitrator ? ` - Arbitrator: ${arbitrator}` : ''}${respondent ? ` - Respondent: ${respondent}` : ''}`;
      }
      
      // Default case: just concatenate the values
      return Object.values(row).filter(v => v !== null).join(" - ");
    });
    
    return {
      answer_type: "list",
      items: items.slice(0, 50), // Limit to 50 items
      summary: `Found ${queryResult.length} results.${queryResult.length > 50 ? " Showing first 50." : ""}`,
      sql_query: sqlQuery,
    };
    
  } catch (error) {
    console.error("Error executing SQL query:", error);
    return {
      answer_type: "error",
      summary: "Error executing the database query.",
      error: (error as Error).message,
      sql_query: sqlQuery,
    };
  }
}

// Function to generate SQL from natural language using the OpenAI model
export async function generateSqlFromNaturalLanguage(question: string): Promise<string> {
  const systemPrompt = `You are an AI assistant that translates natural language questions about arbitration cases into SQL queries.

SCHEMA INFORMATION:
Table: arbitration_cases
- id: integer (primary key)
- case_id: text (unique identifier for the case)
- forum: text (arbitration forum, usually "AAA" or "JAMS")
- arbitrator_name: text (name of the arbitrator)
- respondent_name: text (name of the respondent company)
- consumer_attorney: text (attorney representing the consumer)
- filing_date: timestamp (when the case was filed)
- disposition: text (outcome of the case, e.g., "AWARD", "SETTLEMENT", "WITHDRAWN", "DISMISSED")
- claim_amount: text (amount claimed by the complainant)
- award_amount: text (amount awarded, if any)
- case_type: text (type of case)
- source_file: text (source of the case data)
- processing_date: timestamp (when the case was processed)
- has_discrepancies: boolean (whether there are discrepancies in the data)
- duplicate_of: text (case ID this is a duplicate of, if any)

IMPORTANT RULES:
1. Generate a single valid PostgreSQL query.
2. Do not use double quotes for column names, use snake_case (column names are case sensitive).
3. Use LIKE with wildcards (%term%) for text comparisons to allow for partial matches.
4. Handle NULL values appropriately.
5. Limit results to 50 rows maximum for list-type queries.
6. For monetary calculations (e.g., average awards), consider that award_amount is stored as text and needs to be cast to numeric: NULLIF(award_amount, '')::numeric
7. Always include appropriate WHERE clauses based on the question.
8. For date comparisons, remember filing_date is a timestamp.
9. Return only the SQL query, nothing else.
10. Do not include any explanations or comments in your response.
11. For aggregate queries (COUNT, AVG), use meaningful column aliases.

EXAMPLES:
Question: "How many cases did arbitrator John Smith handle?"
SQL: SELECT COUNT(*) as count FROM arbitration_cases WHERE LOWER(arbitrator_name) LIKE LOWER('%John Smith%');

Question: "What was the average award amount in cases against Chase Bank?"
SQL: SELECT AVG(NULLIF(award_amount, '')::numeric) as avg_award FROM arbitration_cases WHERE LOWER(respondent_name) LIKE LOWER('%Chase Bank%') AND award_amount IS NOT NULL AND award_amount != '';

Question: "List the names of arbitrations handled by arbitrator Jane Doe."
SQL: SELECT case_id, respondent_name, filing_date, disposition FROM arbitration_cases WHERE LOWER(arbitrator_name) LIKE LOWER('%Jane Doe%') LIMIT 50;

Question: "How many times has arbitrator X ruled for the complainant?"
SQL: SELECT COUNT(*) as count FROM arbitration_cases WHERE LOWER(arbitrator_name) LIKE LOWER('%X%') AND LOWER(disposition) LIKE LOWER('%award%');

Translate ONLY the following question into a valid SQL query:`;

  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: question }
    ],
    temperature: 0.1, // Low temperature for more deterministic outputs
    max_tokens: 500
  });

  return response.choices[0].message.content?.trim() || "";
}

// Main function to process a natural language query
export async function processAiQuery(question: string): Promise<QueryResult> {
  try {
    // Generate a SQL query from the natural language question
    const sqlQuery = await generateSqlFromNaturalLanguage(question);
    
    if (!sqlQuery) {
      return {
        answer_type: "error",
        summary: "Failed to generate a SQL query from your question.",
        error: "Empty query generated",
      };
    }
    
    console.log(`Generated SQL query: ${sqlQuery}`);
    
    // Execute the generated query and get the results
    const result = await executeSqlQuery(sqlQuery);
    
    // Enhance the summary with more context based on the question
    if (result.answer_type !== "error") {
      try {
        const enhancedSummary = await generateEnhancedSummary(question, result);
        result.summary = enhancedSummary || result.summary;
      } catch (summaryError) {
        // If we can't generate an enhanced summary, just use the basic one
        console.log("Error generating enhanced summary:", summaryError);
        // Continue with the existing summary
      }
    }
    
    return result;
  } catch (error) {
    console.error("Error processing AI query:", error);
    
    // Check if this is an OpenAI API limit error
    const errorMessage = (error as Error).message || "";
    const isQuotaError = 
      errorMessage.includes("quota") || 
      errorMessage.includes("rate limit") || 
      errorMessage.includes("capacity") ||
      errorMessage.includes("429");
    
    if (isQuotaError) {
      return {
        answer_type: "error",
        summary: "The AI service is currently unavailable due to rate limits. Please try again in a few moments or switch to standard mode.",
        error: "OpenAI API quota exceeded or rate limited",
      };
    }
    
    return {
      answer_type: "error",
      summary: "An error occurred while processing your question.",
      error: (error as Error).message,
    };
  }
}

// Generate a more human-readable summary of the results
async function generateEnhancedSummary(
  question: string, 
  result: QueryResult
): Promise<string> {
  try {
    const prompt = `Question: "${question}"
Result Type: ${result.answer_type}
${result.value !== undefined ? `Value: ${result.value}` : ''}
${result.items ? `Items: ${result.items.slice(0, 5).join(", ")}${result.items.length > 5 ? "..." : ""}` : ''}
SQL Query: ${result.sql_query || "Not available"}

Based on the question and result data above, create a clear, concise, and informative summary sentence that directly answers the user's question.
For count results, specify what was counted.
For average results, clearly state what was averaged and include the value.
For list results, summarize what type of items were found and how many.
Use plain language and avoid technical terms. Do not mention the SQL query.
Keep your response under 150 characters.`;

    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",  // Using a smaller model to save cost/time
      messages: [
        { role: "system", content: "You create concise summaries of database query results." },
        { role: "user", content: prompt }
      ],
      temperature: 0.7,
      max_tokens: 100
    });

    return response.choices[0].message.content?.trim() || result.summary;
  } catch (error) {
    console.error("Error generating enhanced summary:", error);
    return result.summary;  // Fall back to the original summary
  }
}